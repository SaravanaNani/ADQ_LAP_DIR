ROOT - TERRAFORM - CODE -> ENV(DEV/PROD) 
===========================================

1. it creates a single N/W and single subnet , static IP for Ubuntu-desktop(Target VM)

AND 3-firewall rules(["22", "3389", "80", "8080"], ["22", "8080"], ["22", "80"])

Each firewall rule is attached to VM based on N/W tags -> firewall01_network_tags   = "desktop-server"
						       -> firewall02_network_tags   = "tomcat-server"
						       -> firewall03_network_tags   = "apache2-server" 
2. It creates a Service Account - with roles: N/W admin, 
                                              Security Admin,
                                              Service Account user, 
                                              Compute Instance Admin v1,
                                              Storage Admin,

===========================================================================================================
ROOT - ADQ-JENKINS- CODE -> TERRAFORM CODE - JENKINS VM AND Pipelines for Adq-Java-App and Adq-python-App
=============================================================================================================
1. This terraform code Builds Jenkins VM from Base VM, and Static IP for Jenkins VM
 
And firewall Rule for Jenkins Server with  firewall03_network_tags   = "jenkins-server"
 
- The Jenkins VM uses the above created N/W and Subnet and Service Account created in Root N/W terraform Folder

2. Adq-Java-App and Adq-Python-APP folders contains JENKINSFILE for deploying Java and Python Application in 
   
Target VM created by Ubuntu-desktop-App - TERRAFORM CODE FOLDER


========================================================================================================
ROOT - Adq-Ubuntu-Desktop -> CODE - TERRAFORM CODE -> JENKINS FILE -> DOCKERFILE -> ANSIBLE
========================================================================================================

TERRAFORM CODE -it creates a Ubuntu desktop VM via Jenkins File in specified EVN and Uses same N/W & Subnet created 
		in above Root terraform code and also the Static Ip created above 


========================================================================================================================================================================

ANSIBLE/
		/environments -> (dev/prod) ->

		 			inventory.gcp.yaml -> Ansible GCP dynamic inventory config using the ** gcp_compute plugin. 

** It fetches instances from the ** gcp-adq-pocproject-dev ** project using a service account, filtering VMs labeled ** dev=env, ** 

assigning them to the group ** adq_ubuntudesktop ** if their labels include 'adq_ubuntudesktop', and uses their private IP as the 

hostname.

					groups/ - adq_ubuntudesktop.yaml -> It installs Java and tomcat 10 in host labeled as  **adq_ubuntudesktop **
	                			- all.yaml -> it installs in all VM in the Project

ansible.cfg  - Overall: Ensures seamless, automated SSH connections using Jenkins' key for Ansible automation.(SSH keys Are Generated by Docker file for Docker agent)

		
		/roles  -> /Java/tasks/ main.yaml - install java based on dynamic version 

			-> /java-d/tasks/main.yaml - remove java
				
			-> /notepad++/tasks/main.yaml - install notepad ++
			
			-> /notepad-d/tasks/main.yaml - destroy for notepad++

			-> /python/tasks/main.yaml - installs python3

			-> /python-d/tasks/main.yaml - remove python from target node
                       
			-> /tomcat - /handler/main.yaml - perform tomcat installation 
			            /tasks/ main.yaml - one apt update done then notify the handler to perform tomcat install			

			-> /tomcat-d/tasks/main.yaml - removes the tomcat files/ uninstall tomcat


			-> /ubuntudesktop/handler/main.yaml 					
				      /task/main.yaml      Based on whether you're applying or destroying (playbook var), 
                                                           this automates setting up or tearing down a GUI and remote desktop access on an Ubuntu VM.
			
			-> /ubuntudesktop-d  - deletion of ubuntudesktop



playbook_deployment.yml - This playbook applies two roles — ubuntudesktop and tomcat — to all hosts for setting up a GUI and Tomcat server.
                           Roles are tagged for selective execution using Ansible’s --tags option.(tags - tomcat or ubuntu-desktop)

playbook_destroy.yml - This Ansible playbook removes Java, Python, Notepad++, Tomcat, and the Ubuntu desktop GUI by applying their respective destroy roles (*-d).
		       Each role is tagged (java-d, tomcat-d, etc.) for optional selective execution using --tags.

playbook_services.yml - This playbook applies the notepad++ installation role to all hosts, using any configuration values defined in group_vars.
			It is tagged notepad++ so it can be run selectively with --tags notepad++.


playbook_softwares.yml - This playbook installs Java and Python on all hosts by applying the java and python roles.
			 Roles are tagged, allowing you to run specific ones using --tags java or --tags python.


==========================================================================================================================================================================

Dockerfile - This Dockerfile creates a Jenkins agent image based on Ubuntu 20.04, pre-installed with Java (8, 11, 17), Maven, Python, Ansible, Terraform, and Google Cloud SDK.
It sets up SSH access with a jenkins user and SSH key for Jenkins master to connect securely.
The container starts an SSH server, making it ready to be used as a Jenkins build agent over SSH.

==========================================================================================================================================================================

JENKINS FILE - Ubuntudesktop-app

🔁 1. Checkout - Clones the GitHub repo for your IaC project.
 		 Extracts the branch name and sets a display name and description for the current Jenkins build.

✅ 2. Initial Check 

- Stops the pipeline early if both terraform and ANSIBLE are set to skip.

🔐 3. Get credentials

- Copies your GCP service account key (service-account.json) to the workspace.

- Replaces the system Ansible config with your custom one.

📦 4. terraform_plan

- Runs terraform init and terraform plan (if terraform is plan or apply) to show the changes Terraform will make.

📬 5. Request Approval for Terraform Apply
 
- Sends an email asking for approval before applying Terraform changes.

⚙️ 6. Check and Apply Terraform

- After approval:

- If resources already exist, asks again whether to recreate them.

- If no resources exist, runs terraform apply directly.

🔥 7. Request Approval for Terraform Destroy

- Sends an email asking for approval before destroying infrastructure with Terraform.

🧨 8. terraform_destroy

- Waits for user confirmation, then runs terraform destroy to delete infrastructure.

📩 9. Request Approval for Ansible Apply

- Sends an email asking for approval before running the Ansible playbook to configure systems.

⚙️ 10. Playbook_apply

- On approval, runs the Ansible playbook (main.yaml) to apply configuration (e.g., install software, set up environments).

🧹 11. Playbook_destroy

- Runs the Ansible playbook with destroy options to clean up configurations or uninstall components.


 ======================================================================================================================
| Variable               | Description                                                                                 |
| ---------------------- | ------------------------------------------------------------------------------------------- |
| `terraform`            | Controls Terraform flow (`apply`, `plan`, `destroy`, or `skip`).                            |
| `TERRAFORM_EXTRA_ARGS` | Extra flags/options passed to `terraform` commands.                                         |
| `ANSIBLE`              | Controls Ansible execution (`apply`, `destroy`, or `skip`).                                 |
| `ANSIBLE_EXTRA_ARGS`   | Extra flags/options passed to `ansible-playbook`.                                           |
| `BRANCH_NAME`          | Selected Git branch (e.g., `main`, `develop`) — used for checkout.                          |
| `ENV`                  | Environment name (e.g., `dev`, `prod`) — used in path like `terraform/environments/${ENV}`. |
========================================================================================================================= 


===========================================================================================================================================================================


Adq-jenkins/ADQ-JAVA_APP/Jenkinsfile - Java app deployment ✔️ Code checkout → 🔍 Quality check → 📦 Build → ☁️ Upload → ✅ Infra check → 🚀 Deploy → 🛠️ Version update.
============================================================================================================================================================================


🧾 1. Checkout - Clones the GitHub repository for your Java project based on the selected branch.

Extracts and prints the branch name.

🔍 2. SonarQube Analysis

-> Runs mvn sonar:sonar to analyze code quality using SonarQube.

-> Uses the sonar_token credential for authentication.

📦 3. Package

-> Compiles, tests, and packages your Java app into a .war file using Maven.

☁️ 4. Upload Artifact to Nexus

-> Renames the .war file with the current Jenkins build number.

-> Uploads the .war file to a Nexus repository using nexusArtifactUploader.

✅ 5. Check Infrastructure and Request Approval

-> Verifies if the target GCP VM is running.

-> Retrieves its private IP address.

-> Sends an approval email to proceed with deployment.

-> Waits for user input to continue.

🚀 6. Deployment

-> Downloads the .war file from Nexus.

-> Stops the remote Tomcat server.

-> Removes old .war and exploded app directories.

-> Copies the new .war to the remote Tomcat webapps directory.

-> Starts Tomcat again.

🛠️ 7. Update pom.xml Version

-> Clones the GitHub repo again.

-> Updates the <version> in pom.xml to match 1.2.${BUILD_NUMBER}.

-> Commits the change and pushes it back to the same branch using your GitHub PAT.

========================================================================================